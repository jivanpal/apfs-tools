> 原本的项目没有提供可以操作目录的脚本, 另外一个同学提供的python脚本因为几个月没有更新也无法正常运转. 因此, 弄一个coffee的脚本copy文件.

### 编译

```sh
yarn # 安装依赖库
yarn build # 编译
yarn link # 命令行链接
```

### 基础用法

```sh
# 正常使用
bd disk4 /地图 /Volumes/wd4black/back

# 文件或者目录名有空格的时候, 需要双引号
bd disk4 "/地图" "/Volumes/wd4black/back"

# 备份disk4的所有内容, 强烈不建议使用
bd disk4 / /Volumes/wd4black/back
```

### 更多命令

```sh
# 列出系统挂载的disk: 
bd --disklist
# 列出某个disk的afs信息: 
bd --afs disk4
# 列出某个disk的详细afs信息: 
bd --info disk4
# 列出某个disk的某个dir的详细信息: 
bd --list disk4 /
# 备份某个单独的文件, 需要参数: disk, 要被备份的文件路径, 备份copy的目标路径. 命令行的引号不重要
bd --back disk4 /地图/元素周期表-timg-3.jpeg /Volumes/wd4black/back/bbb.jpeg
bd --back disk4 "/地图/元素周期表-timg-3.jpeg" "/Volumes/wd4black/back/ooo/xxx/xox/aaa.jpeg"
```

###### 程序发生错误时, 需要用到的工具

```sh
# 查看多少apfs-tools死在进程中
ps aux | grep apfs-tools
# 根据死在进程中的具体内容, 决定杀掉哪些, 可能这么做就万事大吉了
killall apfs-recover

# 如果遇到node报错: node:events:353 throw er;
# 原因是node的child_process新建子进程stack overflow了, 需要用下面的命令清理
rm -rf node_modules
rm package-lock.json yarn.lock
npm cache clear --force
npm install # 或者yarn

# kill nodejs相关进程
killall node
ps aux | grep node
kill -9 PID
```



### log

###### 20201230

- 开工

```
yarn # 安装依赖包
yarn build # 编译项目
yarn link # 给脚本快捷运行命令
```

###### 20201231

- coffee操作系统命令
- 被master/main坑了, 合并分支.

###### 20210105

```js
//child_process.exec实际调用了下面这个
module.exports.execFile //实际还是调用了spawn
//另一个child_process.spawn()调用了internalBinding
```

- https://medium.com/front-end-weekly/internals-of-node-advance-node-%EF%B8%8F-8612f6a957d7
- https://nodejs.org/dist/latest-v15.x/docs/api/child_process.html

```js
const { spawn } = require('child_process');
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

###### 20210107

- 继续操作命令行
- 有四个函数对spawn进行了包装.
  - child_process.spawn（），
  - child_process.fork（）执行并且建立一个IPC channel, 可以传消息
  - child_process.exec（）包装spawn, 并且使用新的shell
  - child_process.execFile（）包装spawn, 但是不使用新的shell
- 这四个函数都返回childprocess实例
  - 这个对象实现了eventEmitter
  - 因此可以注册listener
  - exec和execfile还可以传入一个回调函数, 在完成命令后回调
- 命令行调用部分形成blog.

###### 20210108

- 包装我的常用函数

```sh
diskutil list
sudo fsck_apfs /dev/disk4
sudo ./bin/apfs-inspect /dev/disk4
sudo ./bin/apfs-list /dev/disk3s2 0 / 

sudo ../bin/apfs-recover /dev/disk4 0 "/地图/元素周期表-timg-3.jpeg" > "/Volumes/wd4black/back/地图/元素周期表-timg-3.jpeg"
mkdir /Volumes/wd4black/back/地图 # 新建目录, 如果目录不存在会报错

#不论是否有引号都可以正常执行.
bd --back disk4 "/地图/元素周期表-timg-3.jpeg" "/Volumes/wd4black/back/aaa.jpeg"
bd --back disk4 /地图/元素周期表-timg-3.jpeg /Volumes/wd4black/back/bbb.jpeg
```

- iscmd需要抽取出来 done
- 单独备份初步完成, 下一步是根据目录情况进行备份.

###### 0110

- 继续处理目录备份

```sh
# 目录拿到的是这个: 
Records for file-system object 0x2 -- `/` --
- INODE
- DIR REC || Dirctry || target ID =     0x10 || name = .Spotlight-V100
- DIR REC || RegFile || target ID =     0x88 || name = .DS_Store
- DIR REC || Dirctry || target ID =     0x8a || name = 地图
- DIR REC || Dirctry || target ID =     0x13 || name = .fseventsd

END: All done.

# 文件拿到的是这个: 
Records for file-system object 0x99 -- `/地图/元素周期表-timg-3.jpeg` --
- INODE
- XATTR
- XATTR
- XATTR
- DSTREAM ID  || file ID =     0x99 || ref. count = 1
- FILE EXTENT || file ID =     0x99 || log. addr. =          0 || length =   237568 B =    0x3a000 B =    58 blocks =    0x3a blocks || phys. block =    0x405d3

END: All done.

# 以地图目录距离
Records for file-system object 0x8a -- `/地图` --
- INODE
- DIR REC || RegFile || target ID =     0x99 || name = 元素周期表-timg-3.jpeg
- DIR REC || RegFile || target ID =     0xa0 || name = 地图-National Geographic Mars Reference Map.jp2
- DIR REC || RegFile || target ID =     0x8b || name = .DS_Store
- DIR REC || RegFile || target ID =     0x97 || name = 元素周期表-0173b05b768daca801218d32832f21.jpg@3000w_1l_0o_100sh.jpg
- DIR REC || RegFile || target ID =     0x9c || name = 地图-hst207_01b_pic.jpg
- DIR REC || RegFile || target ID =     0x98 || name = 元素周期表-timg-2.jpeg
- DIR REC || RegFile || target ID =     0xa4 || name = 地图-National Geographic World Satellite Map.jp2
- DIR REC || Dirctry || target ID =     0x8c || name = ghost in the shell
- DIR REC || RegFile || target ID =     0x9e || name = 地图-National Geographic Earth at Night Map.jp2
- DIR REC || RegFile || target ID =     0xa2 || name = 地图-National Geographic Universe Reference Map.jp2
- DIR REC || RegFile || target ID =     0x9d || name = 地图-National Geographic Antarctica Satellite Map.jpg
- DIR REC || RegFile || target ID =     0xa1 || name = 地图-National Geographic Milky Way Reference Map.jp2
- DIR REC || RegFile || target ID =     0x9b || name = 地图-5db71113h68962619fda1.jpeg
- DIR REC || RegFile || target ID =     0x9f || name = 地图-National Geographic Earth's Fractured Surface Map.jp2
- DIR REC || RegFile || target ID =     0x9a || name = 元素周期表-timg.jpeg
- DIR REC || RegFile || target ID =     0xa5 || name = 地图-v2-5a05688930961118ce12e8801ccfb6a2_r.jpg
- DIR REC || RegFile || target ID =     0xa3 || name = 地图-National Geographic World Physical Ocean Floor.jp2

END: All done.


# 神啊, 还有这种情况:
- INODE
- XATTR
- DIR REC || Dirctry || target ID = 0x943e61 || name = 电影电视剧
- DIR REC || Dirctry || target ID =     0x13 || name = .HFS+ Private Directory Data
- DIR REC || Dirctry || target ID =     0x15 || name = .Spotlight-V100
- DIR REC || RegFile || target ID =     0xb9 || name = .DS_Store
- DIR REC || RegFile || target ID = 0x234dae || name = .disk_label_2x
- DIR REC || Dirctry || target ID = 0x879d0b || name = $RECYCLE.BIN
- DIR REC || Dirctry || target ID =     0x14 || name = .Trashes
- DIR REC || Dirctry || target ID =   0x5e9a || name = 百度云同步盘3
- DIR REC || RegFile || target ID = 0x234daf || name = .VolumeIcon.icns
- DIR REC || Dirctry || target ID =     0x19 || name = .fseventsd
- DIR REC || Dirctry || target ID = 0x27d743 || name = .DocumentRevisions-V100
- DIR REC || RegFile || target ID = 0x234dac || name = tmbootpicker.efi
- DIR REC || RegFile || target ID = 0x234dad || name = .disk_label
- DIR REC || Dirctry || target ID = 0x8a6105 || name = 备份
- DIR REC || Dirctry || target ID = 0x20000003f || name = 音乐
- DIR REC || Dirctry || target ID = 0x27d746 || name = .TemporaryItems
- DIR REC || RegFile || target ID = 0x893ac9 || name = .apdisk

END: All done.
```

###### 0111

```sh
碰到问题: 
node:events:353
      throw er; // Unhandled 'error' event
      ^

Error: read ENOTCONN
```

```sh
rm -rf node_modules
rm package-lock.json yarn.lock
npm cache clear --force
npm install

# kill nodejs相关进程
killall node
ps aux | grep node
kill -9 PID
```

- 然后重启试图解决这个问题

- todo, 记录另一个如果用/作为目录会引起的bug, 没有想好怎么修复

```sh
# todo 如果path=/ 那么下面的语句会导致 //xxx这种, 如果用if判断又比较丑陋, 没想好咋搞.
await back {disk, frompath:"#{frompath}/#{x}", topath:"#{topath}/#{x}"} for x in filelist
bdir {disk, frompath:"#{frompath}/#{x}", topath:"#{topath}/#{x}"} for x in dirlist
```

- 仔细检查, 发现了一个异步引起的问题, 因为异步调用了child_process, 所以会导致资源占用过多, stack_overflow, 由此导致node报错. 

###### 0112

- 打印每一个copy的file, 导致了这个备份过于缓慢. 改为仅仅打印目录. done